<resources>
    <string name="app_name">设计模式</string>
    <string name="action_settings">目录</string>
    <string name="section_format">Hello World from section: %1$d</string>

    <string name="or">或者</string>
    <string name="rn">%s\n%s</string>

    <string name="principle">面向对象的六大原则</string>
    <string name="pattern">设计模式</string>
    <string name="advantages">优点</string>
    <string name="disadvantages">缺点</string>
    <string name="interpreter">用的比较少的行为型模式。</string>
    <string name="command">行为型设计模式之一，相对于其他的设计模式来说，并没有那么多的条条框框。接触比较多的命令模式个例无非就是程序菜单命令。</string>
    <string name="observer">观察者模式在Android中典型实例：ListView的BaseAdapter以及广播。</string>
    <string name="memoto">备忘录模式在Activity中的实例：onSaveInstanceState和onRestoreInstanceState。</string>
    <string name="iterator">几乎每一种高级语言都有相应的内置实现，对于开发者而言，已经极少会由自己来实现迭代器了。\n迭代器模式在Android中典型实例：数据库查询使用的Cursor。</string>
    <string name="template">模板方法模式在Android中的实例：Activity的启动流程onCreate、onStart、onResume。</string>
    <string name="visitor">访问者模式是一种将数据操作与数据结构分离的设计模式，它是《设计模式》中23中设计模式中最复杂的一个。大多数情况下，你并不需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。</string>
    <string name="mediator">在面向对象的编程语言里，一个类必然会与其他类产生依赖关系，如果这种依赖关系如网状般错综复杂，那么必然会影响我们的代码逻辑以及执行效率，适当地使用中介者模式可以对这种依赖关系进行解耦，使逻辑结构清晰，但是，如果几个类间的依赖关系并不复杂，使用中介者模式反而会使得原本不复杂的逻辑结构变得复杂，所以，我们在决定使用中介者模式之前要多方考虑、权衡利弊。</string>
    <string name="composite">组合模式在开发过程中应用不算多，更适用于对一些界面UI的架构设计上。\n在Android中的实例：View和ViewGroup的嵌套组合。</string>
    <string name="adapter">适配器模式在Android中的实例：ListView、GridView、RecyclerView的Adapter。</string>
    <string name="decorator">装饰模式其实并不复杂，就是一种类间的封装，我们在平时的开发过程中也经常会不经意地使用到类似的概念，比如我们常会在Activity的onCreate方法中做一些相关的初始化操作。\n%s\n\n其实如上的一些新增方法的调用就类似装饰模式中装饰者的职责，只不过这里我们没有保持对组件类的引用。\n\n装饰模式和代理模式有点类似，有时甚至容易混淆，倒不是说会把代理模式当成装饰，而常常会是将装饰看作代理。\n装饰模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；\n而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。\n\n装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</string>

    <string name="srp">就一个类而言，应该仅有一个引起它变化的原因，即一个类中应该是一组相关性很高的函数、数据的封装。</string>
    <string name="ocp">软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。因此，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</string>
    <string name="lsp">所有引用基类的地方必须能透明地使用其子类的对象，即只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类；但是反过来就不行了，有子类出现的地方，父类未必就能适应。</string>
    <string name="dip">高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</string>
    <string name="isp">客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上；接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</string>
    <string name="lod">一个对象应该对其他对象有最少的了解，即一个类应该对自己需要耦合或调用的类知道得最少，类的内部何如实现与调用或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。</string>
</resources>
