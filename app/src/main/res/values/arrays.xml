<?xml version="1.0" encoding="utf-8"?>
<resources>
    <array name="design_patterns">
        <item>单例模式——应用最广的模式</item>
        <item>Builder模式——自由扩展你的项目</item>
        <item>原型模式——使程序运行更高效</item>
        <item>工厂方法模式——应用最广泛的模式</item>
        <item>抽象工厂模式——创建型设计模式</item>
        <item>策略模式——时势造英雄</item>
        <item>状态模式——随遇而安</item>
        <item>责任链模式——使编程更有灵活性</item>
        <item>解释器模式——化繁为简的翻译机</item>
        <item>命令模式——让程序畅通执行</item>
        <item>观察者模式——解决解耦的钥匙</item>
        <item>备忘录模式——编程中的“后悔药”</item>
        <item>迭代器模式——解决问题的“第三者”</item>
        <item>模板方法模式——抓住问题核心</item>
        <item>访问者模式</item>
        <item>中介者模式——“和事佬”</item>
        <item>代理模式——编程好帮手</item>
        <item>组合模式——物以类聚</item>
        <item>适配器模式——得心应手的“粘合剂”</item>
        <item>装饰模式</item>
        <item>享元模式——对象共享，避免创建多对象</item>
        <item>外观模式——统一编程接口</item>
        <item>桥接模式——连接两地的交通枢纽</item>
    </array>

    <array name="principles">
        <item>单一职责原则——优化代码的第一步:srp</item>
        <item>开闭原则——让程序更稳定、更灵活:ocp</item>
        <item>里氏替换原则——构建扩展性更好的系统:lsp</item>
        <item>依赖倒置原则——让项目拥有变化的能力:dip</item>
        <item>接口隔离原则——系统有更高的灵活性:isp</item>
        <item>迪米特原则——更好的可扩展性:lod</item>
    </array>

    <array name="singleton_advantages">
        <item>（1）由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</item>
        <item>（2）由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。</item>
        <item>（3）单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时操作。</item>
        <item>（4）单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射关系。</item>
    </array>

    <array name="singleton_disadvantages">
        <item>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码，基本上没有第二种途径可以实现。</item>
        <item>单例对象如果持有Context，那么很容易引发内存泄露，此时需要注意传递给单例对象的Context最好是Application Context。</item>
    </array>

    <array name="builder_advantages">
        <item>（1）良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节。</item>
        <item>（2）建造者独立，容易扩展。</item>
    </array>

    <array name="builder_disadvantages">
        <item>会产生多余的Builder对象以及Director对象，消耗内存。</item>
    </array>

    <array name="prototype_advantages">
        <item>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</item>
    </array>

    <array name="prototype_disadvantages">
        <item>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的，在实际开发当中应该注意这个潜在的问题。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。</item>
    </array>

    <array name="factory_advantages">
        <item>降低了对象之间的耦合度。</item>
        <item>工厂方法模式依赖于抽象的架构，其将实例化的任务交由子类去完成，有非常好的扩展性。</item>
    </array>

    <array name="factory_disadvantages">
        <item>每次我们为工厂方法模式添加新的产品时，就要编写一个新的产品类，同时还要引入抽象层，这必然会导致类结构的复杂化。</item>
    </array>
</resources>